---
title: "f16"
format: html
---

## Announcements

- Enrichment assignment
    - Implementation of half precision IEEE 754 floating point values
    - Use bitwise operations
    - Use numeric operations
    - Combine them.

## Homework

- SHA beckons
- Due Friday, 10 Oct. at 1440 ET.
    - Do not work on this instead of that, after lab section today, until you are done with that.

## Citation

- Basically I try to take Python.Numpy.float16 as the reference implementation, but break from Python on float16 the same places `f32` breaks from `numpy.float32`.

## Today

- [ ] Struct
- [ ] Input/Output
- [ ] Addition/Subtraction
- [ ] Multiplication/Division
- [ ] Optional: Special cases

# Struct

- Before anything else, have to find a way to make an `f16`.
    - We will just use a `u16` and treat it differently.
- We will make a custom data structure that contains precisely a `u16`

```rs
pub struct f16 {
    bits: u16,
}
```

- This probably goes in `lib.rs`
    - Hence the `pub`
    
- You can test that you created a type as follows:
```{.rs filename="src/main.rs"}
fn main() {
    let x : f16::f16;
}
```
- The first `f16` is the crate name, the second is the type name.

### Aside

- For my money, `f16::f16` looks terrible.
```{.rs filename="src/main.rs"}
use f16::*;

fn main() {
    let x : f16;
}
```

### Aside

- We aren't really all the way to teaching structs yet, but feel free to play around with them.
- In particular, you want to have 3 fields, `sign`, `exp`, and `mantissa`, rather than a single `bits` field.
- The internal implementation is up to you with one exception:
    - Only use *integer* operations to emulate floating point operations.
    - (That's what we're trying to learn how to do here).
- You can read more on `struct` here:  [Rust Book 05.01](https://doc.rust-lang.org/book/ch05-01-defining-structs.html)


## Input/Output

- Versus built-in types, we'll just provide a ways to get values in and out.
- We'll use the Rust default integer, `i32`.

- Write the following functions:
```rs
fn i32_to_f16(n:i32) -> f16
fn f16_to_i32(x:f16) -> i32
fn print_f16(x:f16)
```
- You may implement more complex handling, or set every overflow to `inf` and underflow to `0`.
- The following table should be helpful, from the lecture:

| Format | Sign | Exp.  | Mant. | Bits  | Bias | Prec. | 
| :--- | :---: | :---: | :---: | :---: | :---: | :---: |
| Half  | 1 | 5 | 10 | 16 | 15 | 11 |
| Single | 1 | 8 | 23 | 32 | 127 | 24 | 
| Double | 1 | 11 | 52 | 64 | 1023 | 53 | 
| Quad | 1 | 15 | 112 | 128 | 16383 | 113 |

- Here is an example:

