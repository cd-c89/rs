---
title: Packages
---


## Announcements

- The second homework, "Hi cargo", is ready after this class.
  - It is comically trivial.
  - Mostly makes sure you have everything set up.
- Due Friday, 12 Sept. at 1440 ET.

## Today

- Hybrid Day
- Build system/package manager
    - Theory behind Cargo
    - Trap in Cargo
    - Use Cargo

# Build Systems

## Interpretation

- We once again address *interpretation* vs. *compilation*
    - I think of this as *programming* vs. *scripting*
    - We can think in terms of languages - *Rust/C* vs. *Python/JavaScript*

## Scripts

- I regard a script a:
    - Text file
    - Which describes actions for a computer
    - Readable to humans
    - And readable to a *program* (like `python`) which can direct the computer to act
```{.python filename="what_up_earth.py"}
print("what up earth")
```
- We note that this is much closer to being a text file that it is to being a program.

## Programs

- We can create programs but we also use existing programs.
- As an example, consider the Firefox web-browser
    - If you use Chrome, keep that to yourself, that's embarassing. 
- This is what "Firefox.exe" looks like on a Window device.
```{.lisp filename="Firefox.exe"}
AÂ{Å¸@â‚¬Ã¿w.Â·Ã¾9ÃCÃ±Â~Â¿â€°Ã³â‚¬Ã‹ @â‚¬Ã¿Â¶Ã»CÃ¾D8ÃŸuÃ©Â¬%  AÆ’Ã¹/â€žÃ®%  Lâ€¹RHÆ’Ã‚HÆ’Ã€Mâ€¦Ã’â€¦wÃ¿Ã¿Ã¿Mâ€¦Ã€â€žÃƒ  IÂD$Â¹Ã¿   AÂ·Æ’Ãº-â€¦â€œ  IÂPMÂHfAÆ’x-IDÃ‘DÂ·fEâ€¦Ã€â€ž|  EÂ·ÃˆA9Ã‰DCÃEÂHÂ¿Eâ€°Ã‚Aâ‚¬ÃŠ Aâ‚¬Ã¹EÂ¶ÃŠECÃˆAâ‚¬Ã¹câ€¦P  DÂ·BfEâ€¦Ã€â€žA  EÂ·ÃˆA9Ã‰DCÃEÂHÂ¿Eâ€°Ã‚Aâ‚¬ÃŠ Aâ‚¬Ã¹EÂ¶ÃŠECÃˆAâ‚¬Ã¹oâ€¦  DÂ·BfEâ€¦Ã€â€ž  EÂ·ÃˆA9Ã‰DCÃEÂHÂ¿Eâ€°Ã‚Aâ‚¬ÃŠ Aâ‚¬Ã¹EÂ¶ÃŠECÃˆAâ‚¬Ã¹nâ€¦Ãš  DÂ·BfEâ€¦Ã€â€žÃ‹  EÂ·ÃˆA9Ã‰DCÃEÂHÂ¿Eâ€°Ã‚Aâ‚¬ÃŠ Aâ‚¬Ã¹EÂ¶ÃŠECÃˆAâ‚¬Ã¹tâ€¦Å¸  DÂ·BfEâ€¦Ã€â€žÂ  EÂ·ÃˆA9Ã‰DCÃEÂHÂ¿Eâ€°Ã‚Aâ‚¬ÃŠ Aâ‚¬Ã¹EÂ¶ÃŠECÃˆAâ‚¬Ã¹eâ€¦d  DÂ·B
fEâ€¦Ã€â€žU  EÂ·ÃˆA9Ã‰DCÃEÂHÂ¿Eâ€°Ã‚Aâ‚¬ÃŠ Aâ‚¬Ã¹EÂ¶ÃŠECÃˆAâ‚¬Ã¹nâ€¦)  DÂ·BfEâ€¦Ã€â€ž  EÂ·ÃˆA9Ã‰DCÃEÂHÂ¿Eâ€°Ã‚Aâ‚¬ÃŠ Aâ‚¬Ã¹EÂ¶ÃŠECÃˆAâ‚¬Ã¹tâ€¦Ã®   DÂ·BfEâ€¦Ã€â€žÃŸ   EÂ·ÃˆA9Ã‰DCÃEÂHÂ¿Eâ€°Ã‚Aâ‚¬ÃŠ Aâ‚¬Ã¹EÂ¶ÃŠECÃˆAâ‚¬Ã¹pâ€¦Â³   DÂ·BfEâ€¦Ã€â€žÂ¤   EÂ·ÃˆA9Ã‰DCÃEÂHÂ¿Eâ€°Ã‚Aâ‚¬ÃŠ Aâ‚¬Ã¹EÂ¶ÃŠECÃˆAâ‚¬Ã¹ru|DÂ·BfEâ€¦Ã€tqEÂ·ÃˆA9Ã‰DCÃEÂHÂ¿Eâ€°Ã‚Aâ‚¬ÃŠ Aâ‚¬Ã¹EÂ¶ÃŠECÃˆAâ‚¬Ã¹ouIDÂ·BfEâ€¦Ã€t>EÂ·ÃˆA9Ã‰DCÃEÂHÂ¿Eâ€°Ã‚Aâ‚¬ÃŠ Aâ‚¬Ã¹EÂ¶ÃŠECÃˆAâ‚¬Ã¹cufÆ’z â€ž*  Ã«	Æ’Ãº/â€ži#  Lâ€¹ HÆ’Ã€Mâ€¦Ã€â€¦GÃ½Ã¿Ã¿HÂÅ’$Ã°  Ã¨)Ëœ  fÃ¯Ã€LÂâ€ž$   fA@ fA@fA HÂâ€ž$Ã   Hâ€°D$ HÃ‡ÃÃ¿Ã¿Ã¿Ã¿1Ã’AÂ¹0   Ã¨E â€¦Ã€Ë†#  Lâ€¹â€ž$H  Â¹   1Ã’Ã¿Ã» Hâ€°ÃƒHâ€¦Ã€â€ž;#  LÂÂ´$@  AÃ‡FÃ     AÃ†FÃ¸ LÂÅ’$Ã   AÃ‡	  Hâ€°Ã™Âº   Mâ€°Ã°Ã¿ÃµÃº Lâ€°Ã¿â€¦Ã€â€ž4#  â‚¬Â¼$8   â€¦_#  Dâ€¹â€ž$   LÂÂ¼$0  Lâ€°Ã¹Lâ€°Ã²Ã¨â„¢  Aâ‚¬ â€¦X#  LÂÂ´$   AÃ‡FÃ    AÃ†FÃ¸ 1Ã‰Lâ€°Ã²AÂ¸	  Ã¿0Ã¹ =	  tâ€¦Ã€â€¦!  Ã¿Ã¹ Â·Ã¨ÂÃ  â‚¬â€¦Ã€NÃ¨AÂ¼)   @Â¶LÂ=tËœ Hâ€°Ã˜HÃ¿Ã€HÆ’Ã¸r	Hâ€°Ã™Ã¿Â°Ã· @â€žÃ¶â€¦*"  Aâ‚¬Ã·Â³1Ã­HÂ
Â¤ Ã¿â€™Ã¼ Hâ€¦Ã€Lâ€¹d$`â€¦6#  Lâ€¹Mâ€¦Ã€â€žw  IÂD$Â¹Ã¿   AÂ·Æ’Ãº-tÆ’Ãº/â€žÂ»!  Lâ€¹ HÆ’Ã€Mâ€¦Ã€uÃ¢Ã©J  IÂPMÂHfAÆ’x-IDÃ‘DÂ·fEâ€¦Ã€tÃ“EÂ·ÃˆA9Ã‰DCÃEÂHÂ¿Eâ€°Ã‚Aâ‚¬ÃŠ Aâ‚¬Ã¹EÂ¶ÃŠECÃˆAâ‚¬Ã¹luÂ«DÂ·BfEâ€¦Ã€tÂ EÂ·ÃˆAÂºÃ¿   AÂÃ¹Ã¿   EBÃEÂBÂ¿Eâ€°Ã‘Aâ‚¬Ã‰ Aâ‚¬Ã¸EÂ¶ÃECÃ‚Aâ‚¬Ã¸aâ€¦jÃ¿Ã¿Ã¿DÂ·BfEâ€¦Ã€â€ž[Ã¿Ã¿Ã¿EÂ·ÃˆAÂºÃ¿   AÂÃ¹Ã¿   EBÃEÂBÂ¿Eâ€°Ã‘Aâ‚¬Ã‰ Aâ‚¬Ã¸EÂ¶ÃECÃ‚Aâ‚¬Ã¸uâ€¦%Ã¿Ã¿Ã¿DÂ·BfEâ€¦Ã€â€žÃ¿Ã¿Ã¿EÂ·ÃˆAÂºÃ¿   AÂÃ¹Ã¿   EBÃEÂBÂ¿Eâ€°Ã‘Aâ‚¬Ã‰ Aâ‚¬Ã¸EÂ¶ÃECÃ‚Aâ‚¬Ã¸nâ€¦Ã Ã¾Ã¿Ã¿DÂ·BfEâ€¦Ã€â€žÃ‘Ã¾Ã¿Ã¿EÂ·ÃˆAÂºÃ¿   AÂÃ¹Ã¿   EBÃEÂBÂ¿Eâ€°Ã‘Aâ‚¬Ã‰ Aâ‚¬Ã¸EÂ¶ÃECÃ‚Aâ‚¬Ã¸câ€¦â€ºÃ¾Ã¿Ã¿DÂ·B
fEâ€¦Ã€â€žÅ’Ã¾Ã¿Ã¿EÂ·ÃˆAÂºÃ¿   AÂÃ¹Ã¿   EBÃEÂBÂ¿Eâ€°Ã‘Aâ‚¬Ã‰ Aâ‚¬Ã¸EÂ¶ÃECÃ‚Aâ‚¬Ã¸hâ€¦VÃ¾Ã¿Ã¿DÂ·BfEâ€¦Ã€â€žGÃ¾Ã¿Ã¿EÂ·ÃˆAÂºÃ¿   AÂÃ¹Ã¿   EBÃEÂBÂ¿Eâ€°Ã‘Aâ‚¬Ã‰ Aâ‚¬Ã¸EÂ¶ÃECÃ‚Aâ‚¬Ã¸eâ€¦Ã¾Ã¿Ã¿DÂ·BfEâ€¦Ã€â€žÃ¾Ã¿Ã¿EÂ·ÃˆAÂºÃ¿   AÂÃ¹Ã¿   EBÃEÂBÂ¿Eâ€°Ã‘Aâ‚¬Ã‰ Aâ‚¬Ã¸EÂ¶ÃECÃ‚Aâ‚¬Ã¸râ€¦ÃŒÃ½Ã¿Ã¿fÆ’z â€¦ÃÃ½Ã¿Ã¿Hâ€¹Hâ€°HÃ¸HÆ’Ã€Hâ€¦Ã‰uÃ°AÃ¿ÃÂ°Lâ€¹d$`Ã«1Ã€â€žÃ›â€žÃ†   AÃ‡E1Ã‰AÃ¶Ã‡tyLâ€¹Mâ€¦Ã€tqIÂD$Â¹Ã¿   AÂ·Æ’Ãº-uIIÂPMÂPfAÆ’x-IDÃ’DÂ·fEâ€¦Ã€t6EÂ·ÃA9ÃŠDCÃEÂPÂ¿Eâ€°ÃƒAâ‚¬Ã‹ Aâ‚¬ÃºEÂ¶Ã“ECÃAâ‚¬ÃºfuÃ©j   Æ’Ãº/â€ž$  Lâ€¹ HÆ’Ã€Mâ€¦Ã€uâ„¢AÃ¶Ã—EÂ¶Ã‡AÆ’Ã HÂÅ’$Ã°  HÂÅ“$   Hâ€°ÃšÃ¨Ëœ  @Å s@â€žÃ¶â€¦Ã #  Æ’Â¼$    Iâ€°Ã¿u1Ã­Ã«/HÂ
}Â  Ã¿$Ã¹ Hâ€¦Ã€â€¦Ã %  HÂ
```
- I would not regard that as readable to humans (depends on the human)

## Compilation

- Compilation is the process that takes text-based code to whatever we saw on the last slide.
- Can be quite simple - we made `hi_world`, a program, already.
    - Notably it didn't do a lot.
- `rustc` takes a `.rs` file and makes an executable 
  - a program, sort of
- Executables run as command with `./` prefix
  - This differs from `python3` which runs a script **without** creating a corresponding program.

## .py vs .rs

```{mermaid}
%%| theme: Darkly
flowchart LR
  A(Python) --> B[fname.py file]
  B --> C[python fname.py]
  C --> D{hello world}
  E(Rust) --> F[fname.rs  file]
  F --> G[rustc fname.rs]
  G --> H[./fname]
  H --> I{hello world}
```

- _You only have to compile once to have the executable forever._
- _Most programs are executables, not scripts._

## Rustc

- `rustc` is rarely, if ever, used *directly*
  - Over the years (since like, 1960) code has increased in complexity.
    - Many files (think pgl.py, WordleGraphics.py, EnigmaRotor.py)
    - Many libraries (think NumPy, **pandas**, scikit)
    - Complex file systems (01/rustup.md)
- The solution was automation.

## Build Systems

- We don't have a real equivalence to compilation for Python.
    - There is [Numba](https://cd-public.github.io/scicom/0C_numba.html)
- We do have a build system equivalent.
    - I use flit, which is easy.
    - I think there's others... Setuptools? Hatchling?
    
## Flit

- Flit solves a novel problem for Python programers.
    - **Not**: Let's make some code that I can run.
    - **Instead**: Let's make code that can be used in code other people run.
    
## Packaging
    
- NumPy, **pandas**, and things like CS 151 PGL can be "built" into packages with Flit and friends.
    - Basically, instead of running e.g. `python3 mycode.py`
    - Run `flit init` to make a new folder, edit some code, then run `flit publish` to add it to `pip`
- Takeaway - package management and build systems work *real* well together.

## Wheels

- The thing that `flit` and friends create and distribute is not a `.py` file.
- Rather, they are "wheels" which are not human readable.
- *A lot like compiled code*
- Takeaway - a good way to think of Rust is that we're writing packages for ourselves.

## Cargo

- With Python, we use `python3` (or `pip`, but perhaps as `python3 -m pip`).
- `rustc` is not really the equivalent to that:
- Rather, we use `cargo`, the Rust build and package manager.
- `cargo` will handle any usage of `rustc` that we may need.
    - We can easily then distribute code across multiple files.
    
# Cargo New

## Build+Package

- Cargo is Rustâ€™s *build system* (like `flit`) and *package manager* (like `pip`).
- We will use Cargo instead of `rustc` for the rest of the term.
    - My sense is that this is the industry standard.
- We'll step through an example, then you'll do a (very simple) exercise.

## New

- The first thing to do with Cargo, as a rule, is great a new package.
    - This is *kinda* like creating a new `.py` file.
    - It is a bit more like creating a Python project from a template repository.
    
## Do it
    
- To do so:

```{.bash}
cargo new throwaway_example
```

- `cargo` is, well, Cargo
- `new` creates a new package.
- `throwaway_example` is the name of the package[^1].

[^1]: Well, kinda. We'll get to that.

## Examine

- The most natural thing is to see what has changed.
```{.bash}
ls
```
- For me, I see a new directory: `throwaway_example`
- I change into the directory to examine it.
```{.bash}
cd throwaway_example
ls
```
- Not much there:
```{.bash}
Cargo.toml  src
```

## Aside: Tree

- Can also see directory structure.
- Install `tree` with your preferred installer (perhaps `apt` or `brew`)
```{.bash}
sudo apt install tree
```
- Then use `tree` instead of `ls`
```{.bash}
.
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
    â””â”€â”€ main.rs

1 directory, 2 files
```

## main.rs

- Cargo creates projects with a default main file.
```{.rs filename="main.rs"}
fn main() {
    println!("Hello, world!");
}
```
- The name "main" is basically mainful to Cargo - it says which, if multiple, `.rs` files to read first when trying to execute the code in a package.
    - Make sure you understand that sentence.
 
# Cargo Run
 
## Run

- `cargo run` is probably our closest equivalent to `python3 throwaway_example.py` or the "Run" button in VS Code.
- Of note, you can **not** simply do "new" then "run".
    - "New" creates a new folder.
    - "Run" must be done from *within* that folder.

## Try it

- Do this:
```{.bash}
cargo run
```
- See this:
```{.bash}
   Compiling throwaway_example v0.1.0 (/home/user/throwaway_example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.56s
     Running `target/debug/throwaway_example`
Hello, world!
```

## Again!

- If you run again, the process will:
    - Skip the compile step.
    - Be *way* faster (&infin;x reported here)
```{bash}
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/throwaway_example`
Hello, world!
```
- 0.56s -> 0.00s

## It's fast

- 0.56s -> 0.00s
- This is why we use languages which compile.
    - Python took around .04s, for me.
```{.bash}
time python3 -c "print('Hello, world')"
```
- The results are:
```{.bash}
Hello, world

real    0m0.039s
user    0m0.007s
sys     0m0.008s
```
- Guess how long it takes to compile `python`, by the way.

## Other files

- Go ahead and add another `.rs` file and see what happens.
    - Add it to the `src` directory!
- I'll use this one - I change filename and text, but 
```{.rs filename="secondary.rs"}
fn secondary() {
    println!("Goodbye, space!");
}
```

## Run it again...

- Nothing changes.
```{.bash}
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/throwaway_example`
Hello, world!
```
- This is the same as adding another `.py` file then not using `import` or including its code in any other way.

## Swap the names.

- I use `mv` (move) to change:
    - `main.rs` to `old_main.rs`
    - `secondary.rs` to `main.rs`
- Things change!
```{.bash}
   Compiling throwaway_example v0.1.0 (/home/user/throwaway_example)
error[E0601]: `main` function not found in crate `throwaway_example`
 --> src/main.rs:3:2
  |
3 | }
  |  ^ consider adding a `main` function to `src/main.rs`

For more information about this error, try `rustc --explain E0601`.
error: could not compile `throwaway_example` (bin "throwaway_example") due to 1 previous error
```

## Requirements

- You need a `main.rs` with a function named `main`.
- `nvim src/main.rs` -> Change "secondary" to "main" -> "cargo run"
```{.bash}
   Compiling throwaway_example v0.1.0 (/home/user/throwaway_example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.33s
     Running `target/debug/throwaway_example`
Goodbye, space!
```

# Options

## Carry-on only

- I try to live me life without baggage.
    - (I don't like `cargo`)
- Why? Well...
    - I can't name things the way I want
    - I can't add `cargo` created directories to repositories.
- Well, I can, but it I have to use options.

## Option 1: Names

- It is uncommon to name a package numerically.
- It is however, I think, useful in a course.
- It is also, I think, useful to write packages for a course.
- So we do so.

## Name Scheme

- I have used the following scheme this term:
    - Each class day is denoted as a two digit value.
    - The first digit represents the zero-indexed week.
    - The second digit represents the zero-index position in `["Lecture", "Lab", "Homework"]`


## Today

- Today is one week from the first day of class, last week.
- Today is one day from the first day of the week, Monday.
- So I denote today `11`

## Use Cargo

- Let's use `cargo` to make a package called `11`.
```{.bash}
cargo new 11
```
- What happens?

## Problem

```{.bash}
    Creating binary (application) `11` package
error: invalid character `1` in package name: `11`, the name cannot start with a digit
If you need a package name to not match the directory name, consider using --name flag.
If you need a binary with the name "11", use a valid package name, and set the binary name to be different from the package. This can be done by setting the binary filename to `src/bin/11.rs` or change the name in Cargo.toml with:

    [[bin]]
    name = "11"
    path = "src/main.rs"
```

## Solution

- We can make a folder named `11`
- But not a package named `11`.
- We use the `--name` flag.
    - I use the name of these slides, rather than the number, as the package name.
```{.bash}
cargo new 11 --name packages
```
- This should be allowed.

# Exercise

## Exercise

- For the lab today, you must create a:
    [ ] New Cargo project, in
    [ ] A folder named `12`, with
    [ ] A valid Cargo name (not `12`), that is
    [ ] In your *course* repository and therefore
    [ ] Has no `cargo` managed repository.
    


# Fin
